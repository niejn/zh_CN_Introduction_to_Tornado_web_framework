#第二章

**表单和模板**

**Forms and Templates**

在第一章里，我们考察了使用Tornado建立一个web应用的基本知识。涵盖了处理器（handlers）、HTTP请求方式以及Tornado框架的整体架构。在本章中，我们将探究一些在构建web应用时可能会用到的更为强大的特性。

和其它web框架一样，Tornado的一个主要目标就是**帮助使用者更快地写出应用**，尽可能**干净地重用更多代码**。Tornado具备足够的灵活性，允许开发者使用将近所有Python所支持的模板语言，她本身就在`tornado.template`模块中包含有一个轻量快速灵活的模板语言（While Tornado is flexible enough to allow you to use nearly any template language supported by Python, it contains a lightweight, fast, and flexible templating language within the `tornado.template` module）。

##简单示例：诗歌制造专家

**Simple Example: Poem Maker Pro**

让我们以一个叫做*Poem Maker Pro*的简单示例开始。Poem Maker Pro是一个提供了用户去填写的表单的web应用，然后处理出那个表单的结果。示例2-1给出了Python代码。

*示例2-1, 简单表单和模板：poemmaker.py*

```python
#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

import os.path

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render('index.html')


class PoemPageHandler(tornado.web.RequestHandler):
    def post(self):
        noun1 = self.get_argument('noun1')
        noun2 = self.get_argument('noun2')
        noun3 = self.get_argument('noun3')
        verb = self.get_argument('verb')
        self.render('poem.html', roads=noun1, wood=noun2, made=verb,
                difference=noun3)


if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(
        handlers=[(r'/', IndexHandler), (r'/poem', PoemPageHandler)],
        template_path=os.path.join(os.path.dirname(__file__), "templates")
        )
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

除*poemmaker.py*外，还需要位于名为*templates*子目录下的示例2-2及2-3中展示的两个文件。

*例2-2, Poem Maker表单: index.html*

```html
<!DOCTYPE html>
<html>
    <head><title>Poem Maker Pro</title></head>
    <body>
        <h1>Enter terms below.</h1>
        <form method="post" action="/poem">
        <p>Plural noun<br><input type="text" name="noun1"></p>
        <p>Singular noun<br><input type="text" name="noun2"></p>
        <p>Verb (past tense)<br><input type="text" name="verb"></p>
        <p>Noun<br><input type="text" name="noun3"></p>
        <input type="submit">
        </form>
    </body>
</html>
```

*例2-3, Poem Maker模板：poem.html*

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Poem Maker Pro</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    </head>
    <body>
        <h1>你的诗歌</h1>
        <p>Two {{roads}} deverged in a {{wood}}, and I&mdash;<br>
        I took the one less travelled by,<br>
        And that has {{made}} all the {{difference}}
        </p>
    </body>
</html>
```

此时在命令行像这样运行本程式。

`$ python poemmaker.py --port=8000`

现在，将web浏览器指向`http://localhost:8000`。在web浏览器请求根资源（“/”）时，该Tornado程式就会渲染*index.html*，显示出图2-1中的简单HTML表单。

![Poem Maker Pro: 输入表单](images/2-1.png)

*图2-1, Poem Maker Pro: 输入表单*

该表单包含了一个文本字段（分别被命名为`noun1`、`noun2`等等），在用户点击`提交`按钮时，这些字段的内容将以一个`POST`请求方式，发送给`/poem`。现在填写这些字段并点击提交。

作为对那个`POST`请求的响应，该Tornado应用对*poem.html*文件进行渲染，将输入到表单中的值插入进该html文件。结果就是稍微修改过的Robert Frost的“The Road Not Taken”的一个小节。图2-2显示了结果的样子。

![Poem Maker Pro: 输出](images/2-2.png)

*图2-2, Poem Maker Pro: 输出*

**参数`template_path`告诉Tornado到哪里去找模板文件**（*template files*）。在本章及第3章中，都会学到模板文件的准确性质和语法（the exact nature and syntax of templates files）。但其基本要义就是：**模板就是一些可以嵌入小Python代码片段的HTML文件**（templates are HTML files that allow you to embed snippets of Python code）。前面的代码告诉Python在一个位于Tornado应用程序文件相同目录下，名为*templates*的目录中查找模板文件。

而一旦告诉了Tornado到哪里找到这些模板，就可以使用`RequestHandler`类的`render`方法，告诉Tornado去读取一个模板文件，插入在该模板文件总找到的**模板代码**(template code), 接着就将渲染结果发送给浏览器。比如在`IndexHandler`中，就找到下面的代码。

```python
self.render('index.html')
```

这条代码将引发Tornado去找到*templates*目录中的*index.html*文件，读取其内容，然后将其发送给浏览器。

###关于插入

**Interpolation**

结果证明*index.html*根本就不叫”模板“，其包含的完全就是预先制作好的HTML标签（It turns out that *index.html* is hardly a "template" at ll, seeing that it consists entirely of prebaked HTML markup）。这是一个模板的很好用法，但通常我们想要**在HTML输出中结合上程式所传递给模板的一些值**。而为`PoemPageHandler`所渲染的*poem.html*这个模板，就是一个好的例子，我们来看看其是如何工作的。

在文件*poem.html*中，在模板中可以看到几个**用双花括号括起来的字串**，就像这样。

```html
        <p>Two {{roads}} deverged in a {{wood}}, and I&mdash;<br>
        I took the one less travelled by,<br>
        And that has {{made}} all the {{difference}}</p>
```

以双花括号括起来的单词，就叫**占位符**（placeholders），这些就是我们打算在渲染模板时用真实值替换的。通过将关键字参数（keyword arguments）传入给`render`函数，就可以指定哪些值要插入到HTML的哪些位置，而这些关键字是与那些占位符的名称对应的。下面就是`PoemPageHandler`中与此有关的代码部分。

```python
        noun1 = self.get_argument('noun1')
        noun2 = self.get_argument('noun2')
        noun3 = self.get_argument('noun3')
        verb = self.get_argument('verb')
        self.render('poem.html', roads=noun1, wood=noun2, made=verb,
                difference=noun3)
```

这里，我们告诉模板，使用变量`noun1`(它是从`get_argument`方法得到的)作为模板中`roads`的值，变量`noun2`作为模板中`wood` 的值，等等。假设用户在表单中输入了`pineapples`、`grandfather clock`、`irradiated`及`supernovae`，那么结果的HTML将会想这样。

```html
<p>Two pineapples diverged in a grandfather clock, and I&mdash;<br>
I took the one less travelled by,<br>
And that has irradiated all the supernovae.</p>
```

##模板语法

**Template Syntax**

既然已经在上面的例子中碰到了一个简单的模板实例，就来进一步探究一下模板的原理吧。Tornado中的模板，是一些**用Python表达式及控制序列所标记了的简单文本文件**。而Tornado模板的语法，是相当简单直接的（Templates in Tornado are simply text files marked up with Python expressions and control sequences. The syntax of Tornado templates is fairly straightforward and simple）。对Django、Liquid或其它类似框架熟悉的用户，将找到很多的相似之处，并会发现Tornado模板是容易上手的。

在”Simple Example: Poem Maker Pro“中，我们已经展示了在web应用中，如何使用`render`方法将HTML发送给浏览器。你可以在Tornado应用之外，通过在Python解释器下导入模板模块（the template module）, 以直接打印出输出的方式，对模板系统（the templating system）进行试用。

```python
>>> from tornado.template import Template
>>> content = Template("<html><body><h1>{{ header}}</h1></body></html>")
>>> print content.generate(header="欢迎！")
```
```html
<html><body><h1>欢迎！</h1></body></html>
```
