#第四章

**数据库**

**Database**

本章中，将会展示一些用到数据库的Tornado web应用新例子。将以一个简单的RESTful API示例开始，然后继续来创建一个在之前的“模板实践：Burt‘s Books”中引入的Burt's Books网站的完整功能版本。

本章中的示例使用了MongoDB作为数据库，以及pymongo作为接连到MongoDB的Python驱动器。当然，有众多数据库都可以以用在Tornado web应用中，比如Redis、CouchDB及MySQL等几个都是相当著名的选项，同时Tornado本身就带有一个包装MySQL请求的库（Tornado itself ships with a library for wrapping MySQL requests）。选择使用MongoDB是因为其简单性及方便性：安装容易又与Python代码集成很好。其无模式本性令到不必为其预先定义数据结构, 而这对原型设计是极好的（Its schemaless nature makes it unnecessary to predefine your data structures, which is great for prototyping）。

本章中假定在运行示例代码的机器上有一个MongoDB的安装运行着，但将代码修改为使用远端服务器上运行的MongoDB是很容易的。如不想在自己的机器上安装MongoDB, 或者所用系统上没有MongoDB的二进制程序，那么网络上有着一些托管的MongoDB服务（a number of hosted MongoDB services）可以用于替代使用。建议使用[MongoHQ](http://www.mongohq.com/)。在前几个示例中，将假设在本地机器上有MongoDB运行，不过也是很容易将代码修改为运行于远端服务器的（包括MongoHQ）。

同时假定你有一些数据库方面的经验，但并不一定是特定于MongoDB的任何经验。当然，这里只能涉及到MongoDB皮毛的一些东西；一定要读读MongoDB文档([http://www.mongodb.org/display/DOCS/Home](http://www.mongodb.org/display/DOCS/Home)), 获取更多信息。那么就开始吧！

> **译者注：**由于机器上没有MongoDB, 译者对数据库的选用上，对于小数据量，倾向于使用SQLite这样的轻量基于磁盘的数据库C库，其无需单独服务器进程。**SQLite使用非标准的SQL查询语言变体。用于内部数据存储**。在构建应用原型时用SQLite, 然后将代码移植到PostgreSQL这样的更大数据库上。


##使用sqlite3模块对SQLite的基本操作

**Basic SQLite Operations with sqlite3**

在可以写出一个使用SQLite web应用之前，需要学习如何从Python用到SQLite。本小节将学到如何使用sqlite3模块，连接到SQLite数据库，接着就是使用sqlite3来创建、获取及更新一个SQLite数据库中的数据了。

sqlite3模块是由Gerhard Haring编写的，提供了一个符合[PEP 249](http://www.python.org/dev/peps/pep-0249)中描述的DB-API 2.0规范的SQL接口。

###建立一个连接

**Establishing a Connection**

首先，需要导入sqlite3库，并建立一个到某SQLite数据库的连接。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
```

一旦有了一个连接，就可以创建一个焦点对象（a Cursor object），而通过调用焦点对象的`execute()`方法，就可以执行SQL命令了。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
>>> c = conn.cursor()
>>> sqlstr = '''DROP TABLE IF EXISTS stocks'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = '''CREATE TABLE stocks (date text, trans text, symbol text, qty real, price real)'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = "INSERT INTO stocks VALUES ('2006-01-05', 'BUY', 'RHAT', 100, 35.14)"
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> symbol = 'RHAT'
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = '%s'" % symbol
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> t = ('RHAT', )
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = ?"
>>> c.execute(sqlstr, t)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> purchases = [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),]
>>> purchases.append(('2006-04-05', 'BUY', 'MSFT', 1000, 72.00))
>>> purchases.append(('2006-04-06', 'SELL', 'IBM', 500, 53.00))
>>> sqlstr = "INSERT INTO stocks VALUES (?, ?, ?, ?, ?)"
>>> c.executemany(sqlstr, purchases)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> sqlstr = "SELECT * FROM stocks ORDER BY price"
>>> for row in c.execute(sqlstr):
...     print row
...
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)
(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)
(u'2006-04-05', u'BUY', u'MSFT', 1000.0, 72.0)
>>>
```

