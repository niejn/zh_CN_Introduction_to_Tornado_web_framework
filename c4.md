#第四章

**数据库**

**Database**

本章中，将会展示一些用到数据库的Tornado web应用新例子。将以一个简单的RESTful API示例开始，然后继续来创建一个在之前的“模板实践：Burt‘s Books”中引入的Burt's Books网站的完整功能版本。

本章中的示例使用了MongoDB作为数据库，以及pymongo作为接连到MongoDB的Python驱动器。当然，有众多数据库都可以以用在Tornado web应用中，比如Redis、CouchDB及MySQL等几个都是相当著名的选项，同时Tornado本身就带有一个包装MySQL请求的库（Tornado itself ships with a library for wrapping MySQL requests）。选择使用MongoDB是因为其简单性及方便性：安装容易又与Python代码集成很好。其无模式本性令到不必为其预先定义数据结构, 而这对原型设计是极好的（Its schemaless nature makes it unnecessary to predefine your data structures, which is great for prototyping）。

本章中假定在运行示例代码的机器上有一个MongoDB的安装运行着，但将代码修改为使用远端服务器上运行的MongoDB是很容易的。如不想在自己的机器上安装MongoDB, 或者所用系统上没有MongoDB的二进制程序，那么网络上有着一些托管的MongoDB服务（a number of hosted MongoDB services）可以用于替代使用。建议使用[MongoHQ](http://www.mongohq.com/)。在前几个示例中，将假设在本地机器上有MongoDB运行，不过也是很容易将代码修改为运行于远端服务器的（包括MongoHQ）。

同时假定你有一些数据库方面的经验，但并不一定是特定于MongoDB的任何经验。当然，这里只能涉及到MongoDB皮毛的一些东西；一定要读读MongoDB文档([http://www.mongodb.org/display/DOCS/Home](http://www.mongodb.org/display/DOCS/Home)), 获取更多信息。那么就开始吧！

> **译者注：**由于机器上没有MongoDB, 译者对数据库的选用上，对于小数据量，倾向于使用SQLite这样的轻量基于磁盘的数据库C库，其无需单独服务器进程。**SQLite使用非标准的SQL查询语言变体。用于内部数据存储**。在构建应用原型时用SQLite, 然后将代码移植到PostgreSQL这样的更大数据库上。


##使用sqlite3模块对SQLite的基本操作

**Basic SQLite Operations with sqlite3**

在可以写出一个使用SQLite web应用之前，需要学习如何从Python用到SQLite。本小节将学到如何使用sqlite3模块，连接到SQLite数据库，接着就是使用sqlite3来创建、获取及更新一个SQLite数据库中的数据了。

sqlite3模块是由Gerhard Haring编写的，提供了一个符合[PEP 249](http://www.python.org/dev/peps/pep-0249)中描述的DB-API 2.0规范的SQL接口。

###建立一个连接

**Establishing a Connection**

首先，需要导入sqlite3库，并建立一个到某SQLite数据库的连接。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
```

一旦有了一个连接，就可以创建一个焦点对象（a Cursor object），而通过调用焦点对象的`execute()`方法，就可以执行SQL命令了。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
>>> c = conn.cursor()
>>> sqlstr = '''DROP TABLE IF EXISTS stocks'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = '''CREATE TABLE stocks (date text, trans text, symbol text, qty real, price real)'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = "INSERT INTO stocks VALUES ('2006-01-05', 'BUY', 'RHAT', 100, 35.14)"
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> symbol = 'RHAT'
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = '%s'" % symbol
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> t = ('RHAT', )
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = ?"
>>> c.execute(sqlstr, t)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> purchases = [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),]
>>> purchases.append(('2006-04-05', 'BUY', 'MSFT', 1000, 72.00))
>>> purchases.append(('2006-04-06', 'SELL', 'IBM', 500, 53.00))
>>> sqlstr = "INSERT INTO stocks VALUES (?, ?, ?, ?, ?)"
>>> c.executemany(sqlstr, purchases)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> sqlstr = "SELECT * FROM stocks ORDER BY price"
>>> for row in c.execute(sqlstr):
...     print row
...
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)
(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)
(u'2006-04-05', u'BUY', u'MSFT', 1000.0, 72.0)
>>>
```

###SQLite表记录与JSON

**SQLite Table Records and JSON**

在开发web应用时，经常要将一个Python字典变量序列化为一个JSON对象（比如，作为对一次AJAX请求的响应）。而使用sqlite3从SQLite中取得的记录是简单的元组（tuple），在将其转换成字典后，就假定可以通过将其传递给`json`模块的`dumps`函数，而简单地转换成JSON对象。

```python
>>> import sqlite3
>>> import json
>>> conn = sqlite3.connect('example.db')
>>> cur = conn.cursor()
>>> sqlstr = "SELECT * FROM stocks ORDER BY price"
>>> names = ('date', 'trans', 'symbol', 'qty', 'price')
>>> results = list()
>>> for row in cur.execute(sqlstr):
...     result = dict()
...     for i  in range(5):
...         result[names[i]] = row[i]
...
...     results.append(result)
...
>>> for res in results:
...     json.dumps(res)
...
'{"date": "2006-01-05", "symbol": "RHAT", "trans": "BUY", "price": 35.14, "qty": 100.0}'
'{"date": "2006-03-28", "symbol": "IBM", "trans": "BUY", "price": 45.0, "qty": 1000.0}'
'{"date": "2006-04-06", "symbol": "IBM", "trans": "SELL", "price": 53.0, "qty": 500.0}'
'{"date": "2006-04-05", "symbol": "MSFT", "trans": "BUY", "price": 72.0, "qty": 1000.0}'
```

##一个简单的持久化web服务

**A Simple Persistent Web Service**

现在我们已经掌握了编写一个访问SQLite数据库中数据的足够知识。首先，将要写出一个仅从SQLite中读取数据的web服务。接着要写一个读和写数据的。

###一个只读词典应用

**A Read-Only Dictionary**

将要构建的这个应用是一个简单的基于web的字典。只能发出每个特定单词的请求，然后回来的是那个单词的定义。下面就是一个典型的交互看起来的样子。

```bash
$ curl http://localhost:8000/oarlock
{definition: "A device attached to a rowboat to hold the oars in place", "word": "oarlock"}
```

此web服务将从一个SQLite数据库中拉取数据。肯定的是，将会通过数据表的`word`字段来查找记录。在实际研究该web应用的源码前，先通过Python交互式解释器将一些单词加入到数据库中吧。

```python
import sqlite3
conn = sqlite3.connect('example.db')
cur = conn.cursor()
sqlstr = "DROP TABLE IF EXISTS dict"
cur.execute(sqlstr)
sqlstr = "CREATE TABLE dict (word text, definition text)"
cur.execute(sqlstr)
words = [('oarlock', 'A device attatched to a rowboat to hold the oars in place'),]
words.append(('seminomadic', 'Only partially nomadic'))
words.append(('perturb', 'Bother, unsettle, modify'))
sqlstr = "INSERT INTO dict VALUES (?, ?)"
cur.executemany(sqlstr, words)
```

示例4-1中是字典web服务的源码，该程式将对上面加入的单词进行查找，并以单词定义响应查询请求。

*例4-1, 字典web服务：definition_readonly.py*

```python
#!/usr/bin/env python2.7
# -*-coding: utf-8**

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
import os.path

import sqlite3

from tornado.options import define, options
define("port", default=8000, help=u"在给定的端口上运行", type=int)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))


def _execute(query):
    '''用于执行到一个本地sqlite数据库的查询'''
    dbPath = os.path.join(BASE_DIR, 'example.db')
    conn = sqlite3.connect(dbPath)
    cursorobj = conn.cursor()
    try:
        cursorobj.execute(query)
        result = cursorobj.fetchall()
        conn.commit()
    except:
        raise
    conn.close()
    return result


class Application(tornado.web.Application):
    def __init__(self):
        handlers = [(r"/(\w+)", WordHandler)]
        tornado.web.Application.__init__(self, handlers, debug=True)


class WordHandler(tornado.web.RequestHandler):
    def get(self, word):
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        ret = dict()
        ret['word'] = word
        res = _execute(sql)
        if res:
            ret['definition'] = res[0][0]
            self.write(ret)
        else:
            self.set_status(404)
            self.write({"error": "word not found"})
        # self.application.conn.close()

if __name__ == "__main__":
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(Application())
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

在命令行上像下面这样运行此程式。

```bash
$ python definitions_readonly.py
```

现在使用`curl`或web浏览器来向该应用发出一个请求。

```bash
$ curl http://localhost:8000/perturb
{"definition": "Bother, unsettle, modify", "word": "perturb"}
```

假如请求了一个未曾加入到数据库的单词，就会得到一个404响应，以及一个错误消息。

```bash
$ curl http://localhost:8000/snorkle
{"error": "word not found"}
```

那么这个程式是怎么工作的呢？ 我们来讨论一下代码中的一些关键行。一开始，在程式顶部通过`import sqlite3`将Python模块`sqlite3`装入进来。接着编写了一个全局函数`_execute`, 该函数封装了SQLite数据库查询。

```python
def _execute(query):
    '''用于执行到一个本地sqlite数据库的查询'''
    dbPath = os.path.join(BASE_DIR, 'example.db')
    conn = sqlite3.connect(dbPath)
    cursorobj = conn.cursor()
    try:
        cursorobj.execute(query)
        result = cursorobj.fetchall()
        conn.commit()
    except:
        raise
    conn.close()
    return result
```

一旦有了这个全局函数，就可以在程式的任意地方执行SQL查询了。下面是`WordHandler`类的`get`方法。

```python
    def get(self, word):
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        ret = dict()
        ret['word'] = word
        res = _execute(sql)
        if res:
            ret['definition'] = res[0][0]
            self.write(ret)
        else:
            self.set_status(404)
            self.write({"error": "word not found"})
```

###往词典中写入记录

**Writing the Dictionary**

在词典中查找单词是很好玩的，但之前必须要通过交互式Python解释器加入单词却始终是个困扰。示例中的下一步，就要让经由给该web服务发起HTTP请求给的方式，来创建或是修改单词记录成为可能。

它将这样工作，对某个特定单词发出的`POST`请求，将用请求主体所给出的定义来对既有定义进行修改。而如果该特定单词尚不存在，就创建该单词的记录。比如，要创建一个新单词，就像下面这样操作。

```bash
$ curl -d definition=a+leg+shirt http://localhost:8000/pants
{"definition": "a leg shirt", "word": "pants"}
```

这样就创建出了该单词，就可以通过一个`GET`请求，请求到这个单词。

```bash
$ curl http://localhost:8000/pants
{"definition": "a leg shirt", "word": "pants"}
```

通过执行一个带有某个单词的定义字段的`POST`请求，可以对某个既有单词进行修改（与创建一个新的单词所用的参数相同）。

```bash
$ curl -d definition=a+boat+wizard http://localhost:8000/oarlock
{"definition": "a boat wizard", "word": "oarlock"}
```

示例4-2是读/写版本的词典web服务源码。

*例4-2, 一个可读/写的词典服务：definitions_readwrite.py*

```python
#!/usr/bin/env python2.7
# -*-coding: utf-8**

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
import os.path

import sqlite3

from tornado.options import define, options
define("port", default=8000, help=u"在给定的端口上运行", type=int)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))


def _execute(query):
    '''用于执行到一个本地sqlite数据库的查询'''
    dbPath = os.path.join(BASE_DIR, 'example.db')
    conn = sqlite3.connect(dbPath)
    cursorobj = conn.cursor()
    try:
        cursorobj.execute(query)
        result = cursorobj.fetchall()
        conn.commit()
    except:
        raise
    conn.close()
    return result


class Application(tornado.web.Application):
    def __init__(self):
        handlers = [(r"/(\w+)", WordHandler)]
        tornado.web.Application.__init__(self, handlers, debug=True)


class WordHandler(tornado.web.RequestHandler):
    def get(self, word):
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        ret = dict()
        ret['word'] = word
        res = _execute(sql)
        if res:
            ret['definition'] = res[0][0]
            self.write(ret)
        else:
            self.set_status(404)
            self.write({"error": "word not found"})
        # self.application.conn.close()

    def post(self, word):
        definition = self.get_argument("definition")
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        output = dict()
        output["word"] = word
        output["definition"] = definition
        res = _execute(sql)
        if res:
            sql = "UPDATE dict SET definition = '%s' WHERE word = \
                    '%s'" % (definition, word)
            _execute(sql)
        else:
            sql = "INSERT INTO dict VALUES ('%s', '%s')" % (word, definition)
            _execute(sql)
        self.write(output)

if __name__ == "__main__":
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(Application())
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

除了`WordHandler`中增加的`post`方法，该源码与只读服务完全一样。来细细地研究一下这个方法。

```python
    def post(self, word):
        definition = self.get_argument("definition")
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        output = dict()
        output["word"] = word
        output["definition"] = definition
        res = _execute(sql)
        if res:
            sql = "UPDATE dict SET definition = '%s' WHERE word = \
                    '%s'" % (definition, word)
            _execute(sql)
        else:
            sql = "INSERT INTO dict VALUES ('%s', '%s')" % (word, definition)
            _execute(sql)
        self.write(output)
```

完成的第一件事就是使用`ReqestHandler`类的`get_argument`方法来取得自`POST`请求传入的`definition`参数。接着，如同在`get`方法中一样，调用全局函数`_execute`尝试从数据库查找请求路径中那个单词。如找到该单词，就将该单词对应记录的`definition`字段更新为从`POST`参数得到的字串。有没有找到该单词，就又通过全局函数`_execute`在数据库中创建一条新的记录。在两种情况下，都会将一个字典写入到对请求的响应中。

##Burt的书店

**Burt's Books**

第3章中，展示了一个作为说明如何使用Tornado的那些模板工具，来构建负责web应用的实例的Burt's Books应用。在本节中
